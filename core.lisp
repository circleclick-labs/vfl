(defmacro  n   (&rest     r) `(progn            ,@r))
(defmacro !=   (&rest     r) `(not         (eql ,@r)))
(defmacro ==   (&rest     r) `(             eql ,@r))
(defmacro :=   (&rest     r) `(setf             ,@r))
(defmacro hc   (&rest     r) `(handler-case     ,@r))
(defmacro  $   (&rest     r) `(let* ,@r ,(caar (last (car r)))))
(defun  :...   (&rest     r)  (apply 'list*       r))
(defun    ^.   (&rest     r)  (apply 'list*       r))
(defun    ^-   (&rest     r)  (declare (ignore r)) (values))
(defun    ^^   (&rest     r)  (apply 'values-list r))
(defun    ^    (&rest     r)  (apply 'values      r))
(defun    ⋯    (&rest     r)  (apply 'list*       r))
(defun    …    (&rest     r)  (apply 'list*       r))
(defun    f.   (&rest     r)  (apply 'format t    r) (terpri) (^))
(defun    p. (x &optional s)  (prin1 x s) (terpri s) x)
(defun fpos              (s)  (file-position      s))
(defun shortname () (enough-namestring *load-truename* (truename ".")))
(require 'asdf)
(defvar *args* (copy-list (uiop:command-line-arguments)))
(shadow '(print)) (defun print (x) (p. x))
