(defmacro  $   (&rest     r) `(let* ,@r ,(caar (last (car r)))))
(defmacro  q   (&rest     r) `(quote                    ,@r))
(defmacro  n   (&rest     r) `(progn                    ,@r))
(defmacro  a   (&rest     r) `(apply                    ,@r))
(defmacro :=   (&rest     r) `(setf                     ,@r))
(defmacro hc   (&rest     r) `(handler-case             ,@r))
(defun    !=   (&rest     r)        (if (apply 'eql r) () t))
(defun    ==   (&rest     r)        (if (apply 'eql r) t ()))
(defun    ^-   (&rest     r)  (declare (ignore r))  (values))
(defun    ^.   (&rest     r)  (a 'list*                   r))
(defun    ^^   (&rest     r)  (a 'values-list             r))
(defun    ^    (&rest     r)  (a 'values                  r))
(defun    cs   (&rest     r)  (a 'concatenate 'string     r))
(defun    s-   (&rest     r)  (a 'format nil              r))
(defun    f.   (&rest     r)  (a 'format t r)   (^- (terpri)))
(defun    p. (x &optional s)  (prin1 x s)           (terpri s) x)
(defun shortname () (enough-namestring *load-truename* (truename ".")))
(require 'asdf)
(defvar *args* (copy-list (uiop:command-line-arguments)))
(shadow '(print)) (defun print (x) (p. x))
